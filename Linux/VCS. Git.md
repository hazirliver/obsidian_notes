`diff -u file1 file2` -- позволяет вывести строки, отличающиеся между файлами в унифицированном формате

`patch old_file patch_file` -- перезаписывает старый файл с учетом изменений, лежащих во втором аргументе

---
# Первоначальная конфигурация

| Команда                        | Описание                                           |
| ------------------------------ | -------------------------------------------------- |
| `git config --local user.name` | Установить для текущего репозитория параметр имени |
| `git config --local user.name` | Установить для текущего репозитория параметр почты |
| `git config --global core.editor "nvim"` | Использовать `nvim` как редактор по умолчанию                                |                                                    |

# Инициализация репозитория

| Команда         | Описание                          |
| --------------- | --------------------------------- |
| `git clone url` | Клонирование репозитория по `url` |
| `git init`      | Создание пустого гит репозитория в текущей директории                                  |

# Отслеживание

*Staging area (index)* -- файл, поддерживаемый Git'ом, который содержит всю информацию о том, какие файлы и изменения войдут в следующий комит

![[staging_area.png]]

_Changes to be committed_ -- изменение в настоящий момент находится в *промежуточной области* (staging area)

| Команда         | Описание                                                                                      |
| --------------- | --------------------------------------------------------------------------------------------- |
| `git add file`  | Доабвить `file` к списку отслеживаемых с помощью git  (переместить в staging area)            |
| `git status`    | Позволяет получить некоторую информацию о текущем рабочем дереве и ожидающих изменениях       |
| `git commit`    | Позволяет сохранить изменения из staging area в .git репозиторий                              |
| `git log`       | Позволяет посмотреть историю коммитов текущего проекта                                        |

| `git commit -a`      | Переносит все изменения в отслеживаемых файлах в staging area_ и делает коммит в одну команду                       |
| -------------------- | ------------------------------------------------------------------------------------------------------------------- |
| `git log -p`         | Отображает конкретные изменения                                                                                     |
| `git log -n`         | Выводит информацию только о `n` предыдущих коммитах                                                                                                                    |
| `git show commid_id` | Отображает патч коммита `commit_id`                                                                                 |
| `git log --stat`     | Отображает статистику коммитов: сколько строк было изменено (сколько добавлено, сколько удалено)                    |
| `git diff`           | Эквивалент `diff -u`                                                                                                |
| `git add -p`         | Добавляет проверку перед переносом файла в staging area                                                             |
| `git diff --staged`  | Позволяет посмотреть изменения, которые находятся в staging area, но не закомичены                                  |
| `git rm fname`       | Останавливает отслеживание файла `fname` и удаляет его из гит репозитоия. Удаления также нужно коммитить            |
| `git mv`             | Переименовать файл в репозитории. Изменения также сначала попадают в staging area, откуда затем нужно сделать комит |

| `git checkout fname`      | Отменить текущие незакоммиченные изменения и откатить `fname` к состаянию из текущего снепшота |
| ------------------------- | ---------------------------------------------------------------------------------------------- |
| `git reset HEAD fname`    | Перестает отслеживать файл `fname` (Удаляет его из staging area)                               |
| `git reset HEAD fname -p` | Добавляет проверку для каждого случая перед удалением из staging area                          |
| `git commit --amend`      | Редактирует предыдущий коммит                                                                  |

| `git revert` | Делает новый коммит с изменениями, обратными предыдущему коммиту |
| ------------ | ---------------------------------------------------------- |
|              |                                                            |

# Хороший тон `git commit`'a

1. <i>Первая строка</i> комита содержит краткое описание того, что происходит в комите. Она содержит должна содержать до <u>50 символов</u>
2. <i>Вторая строка</i> должна быть пустой
3. Далее идет подробное описание комита. <i>Каждая строка</i> должна быть <u>короче 72 символов</u>
4. Писать комиты следует в <u>повелительном наклонении</u>: "Fix bug" and not "Fixed bug" or "Fixes bug"

Строки, начинающиеся с символа `#` соответствуют комментариям, которые не пойдут в коммит

* `git commit --amend` следует использовтаь только в локальных репозиториях и нужно <u>избегать использования этой опции в публичных репозиториях</u>, посколько `--amend` перезаписывает предыдущий коммит!

* commit id генерируется алгоритмом SHA1 и имеет длину 40 символов. Генерация хеша происходит по всем данным, относящимся к текущему изменению

# HEAD
Git использует HEAD для отображения текущего проверенного снепшота проекта. HEAD используется для указания текущего рабочего снепшота с которым мы работаем. _Указатель на текущую ветку_

* Все операции по типу `git status`, `git diff` и прочие будут работать с текущим снепшотом в соответствии с HEAD

# .gitignore
* Данный файл содержит правила, которые сообщают Git'у, какие файлы скипать для данного репозитория

# Ветки (Branch)

> <u>Branch (ветка)</u> -- указатель на определенный коммит

* Бранчи представляют собой независимые линии развития в проекте
* Ветка по умолчанию, которая создается при инициализации репозитория называется `master`
	* Ветка `mster` используются для представления изветсного хорошего состояния проекта
* Создавая новые ветки, мы можем экспериментировать без боязни испортить мастер-ветку и повалить продакшн проекта
* Создание новой ветки не приводит к копированию каких-либо файлов

| Команда                      | Описание                                                            |
| ---------------------------- | ------------------------------------------------------------------- |
| `git branch`                 | Отобразить все ветки текущего репозитория                           |
| `git bracnh new-branch`      | Создание новой ветки с именем `new-branch`                          |
| `git checkout new-branch`    | Переключение на ветку `new-branch`                                  |
| `git checkout -b new-branch` | Создать новую ветку `new-branch` и сразу переключиться на нее       |
| `git branch -d new-branch`   | Удалить ветку с именем `new-branch`                                 |
| `git branch -D new-bracnh`   | Удалить ветку `new-branch`, имеющую незамерженые в мастер изменения |
|                              |                                                                     |

# Слияние (Meging)

> Merging (слияние) -- термин, который Git использует для объединения данных и истории веток

* После мерджа две втеки указывают на один коммит


| Команда                  | Описание                         |
| ------------------------ | -------------------------------- |
| `git merge other-branch` | Вмердживает ветку `other-branch` |


Гит использует два различных подхода для выполнения слияния:
* fast-forward merge
* three-way merge

## Fast-forward merge

Этот вид слияния происходит, когда все комиты в checkout-ветке также находятся в ветке, которую будем вмердживать

В этом случае история комитов двух веток не расходится

Git просто обновляет указатели веток. Фактического слияния не происходит

## Three-way merge

Трехстороннее слияние происходит, когда история смердживающихся веток отличается. В этом случае нет хорошего линейного спооба объединить две ветки обычным перекидыванием указателей

Например, это может произойти, если бы мы сделали комит на мастер-ветке после создания новых веток 

Если изменения были сделаны в разных файлах или в разных частях одного и того же файла, Git будет принимать оба изменения и объединять результат

Если изменения будут сделаны в одной и той же части одного и того же файл, Git не будет знать как объединить эти изменения и попытка мерджа приведет к конфликту слияния (<u>merge conflict</u>)

| Команда                     | Описание                                                                                  |
| --------------------------- | ----------------------------------------------------------------------------------------- |
| `git log --graph --oneline` | Отображает граф логов с одной строкой на комит                                            |
| `git merge --abort`         | Остановка слияния и сброс файлов в working tree обратно к предыдущему комиту (до слияния) |
|                             |                                                                                           |

